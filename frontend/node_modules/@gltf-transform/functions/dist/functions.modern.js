import{Primitive as e,bounds as t,PropertyType as n,BufferUtils as r,Root as o,Texture as s,ExtensionProperty as i,ImageUtils as a,MathUtils as c,Node as l,AnimationChannel as g,Scene as u,Accessor as f,AnimationSampler as p,Material as m,TextureChannel as d,uuid as h,TextureInfo as A}from"@gltf-transform/core";export{bounds}from"@gltf-transform/core";import{getPixels as y,savePixels as E}from"ndarray-pixels";import{MeshQuantization as T,DracoMeshCompression as S,MeshGPUInstancing as I,MeshoptCompression as b,MaterialsIOR as w,MaterialsSpecular as N,MaterialsPBRSpecularGlossiness as M,TextureWebP as R,MaterialsUnlit as O}from"@gltf-transform/extensions";import{invert as C,fromRotationTranslationScale as P,fromScaling as x,multiply as z}from"gl-matrix/mat4";import{transformMat4 as $,min as v,scale as L,max as _,normalize as q}from"gl-matrix/vec3";import G from"ndarray";import{lanczos3 as k,lanczos2 as B}from"ndarray-lanczos";function F(){return(F=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function U(e,t){return Object.defineProperty(t,"name",{value:e}),t}function W(e,t,n){return!!e&&e.stack.lastIndexOf(t)<e.stack.lastIndexOf(n)}async function H(e,t,n){if(!e)return null;const r=e.getImage();if(!r)return null;const o=await y(r,e.getMimeType());for(let e=0;e<o.shape[0];++e)for(let t=0;t<o.shape[1];++t)n(o,e,t);const s=await E(o,"image/png");return t.setImage(s).setMimeType("image/png")}class j{constructor(){this._map=new Map}get size(){return this._map.size}has(e){return this._map.has(e)}add(e,t){let n=this._map.get(e);return n||(n=new Set,this._map.set(e,n)),n.add(t),this}get(e){return this._map.get(e)||new Set}keys(){return this._map.keys()}}function V(e,t=2){if(0===e)return"0 Bytes";const n=t<0?0:t,r=Math.floor(Math.log(e)/Math.log(1e3));return parseFloat((e/Math.pow(1e3,r)).toFixed(n))+" "+["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"][r]}function D(e){return e.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")}function X(e,t){return`${D(e)} → ${D(t)} (${function(e,t,n=2){return(e>t?"–":"+")+(Math.abs(e-t)/e*100).toFixed(n)+"%"}(e,t)})`}function K(e){const t=[];for(const n of e.listAttributes())t.push(n);for(const n of e.listTargets())for(const e of n.listAttributes())t.push(e);return Array.from(new Set(t))}function J(e,t,n){e.swap(t,n);for(const r of e.listTargets())r.swap(t,n)}function Z(e,t,n){const r=e.getElementSize(),o=e.getCount(),s=e.getArray(),i=s.slice(0,n*r);for(let e=0;e<o;e++)for(let n=0;n<r;n++)i[t[e]*r+n]=s[e*r+n];e.setArray(i)}function Q(e,t=e){const n=t<=65534?new Uint16Array(e):new Uint32Array(e);for(let e=0;e<n.length;e++)n[e]=e;return n}const Y={pivot:"center"};function ee(e=Y){const n=F({},Y,e);return U("center",e=>{const r=e.getLogger(),o=e.getRoot(),s=o.listAnimations().length>0||o.listSkins().length>0;e.getRoot().listScenes().forEach((i,a)=>{let c;if(r.debug(`center: Scene ${a+1} / ${o.listScenes().length}.`),"string"==typeof n.pivot){const e=t(i);c=[(e.max[0]-e.min[0])/2+e.min[0],(e.max[1]-e.min[1])/2+e.min[1],(e.max[2]-e.min[2])/2+e.min[2]],"above"===n.pivot&&(c[1]=e.max[1]),"below"===n.pivot&&(c[1]=e.min[1])}else c=n.pivot;r.debug(`center: Pivot "${c.join(", ")}".`);const l=[-1*c[0],-1*c[1],-1*c[2]];if(s){r.debug("center: Model contains animation or skin. Adding a wrapper node.");const t=e.createNode("Pivot").setTranslation(l);i.listChildren().forEach(e=>t.addChild(e)),i.addChild(t)}else r.debug("center: Skipping wrapper, offsetting all root nodes."),i.listChildren().forEach(e=>{const t=e.getTranslation();e.setTranslation([t[0]+l[0],t[1]+l[1],t[2]+l[2]])})}),r.debug("center: Complete.")})}const te="colorspace";function ne(e){return U(te,t=>{const n=t.getLogger();if("linear"===e.inputEncoding)return void n.info(`${te}: Vertex colors already linear. Skipping conversion.`);if("sRGB"!==e.inputEncoding)return void n.error(`${te}: Unknown input encoding "${e.inputEncoding}" – should be "sRGB" or "linear". Skipping conversion.`);const r=new Set;function o(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function s(e){const t=[0,0,0];let n;for(let s=0;n=e.getAttribute(`COLOR_${s}`);s++)if(!r.has(n)){for(let e=0;e<n.getCount();e++)n.getElement(e,t),t[0]=o(t[0]),t[1]=o(t[1]),t[2]=o(t[2]),n.setElement(e,t);r.add(n)}}t.getRoot().listMeshes().forEach(e=>e.listPrimitives().forEach(s)),n.debug(`${te}: Complete.`)})}const re={propertyTypes:[n.ACCESSOR,n.MESH,n.TEXTURE,n.MATERIAL]},oe=function(e=re){const t=F({},re,e),s=new Set(t.propertyTypes);for(const e of t.propertyTypes)if(!re.propertyTypes.includes(e))throw new Error(`dedup: Unsupported deduplication on type "${e}".`);return U("dedup",e=>{const t=e.getLogger();s.has(n.ACCESSOR)&&function(e,t){const n=new Set,o=new Set,s=new Set,i=new Set,a=t.getRoot().listMeshes();a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(e=>o.add(e));const t=e.getIndices();t&&n.add(t)})});for(const e of t.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),n=t.getOutput();e&&s.add(e),n&&i.add(n)}function c(e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n],s=r.toView(o.getArray());if(!t.has(o))for(let n=0;n<e.length;n++){const i=e[n];o!==i&&(t.has(i)||o.getType()===i.getType()&&o.getComponentType()===i.getComponentType()&&o.getCount()===i.getCount()&&o.getNormalized()===i.getNormalized()&&r.equals(s,r.toView(i.getArray()))&&t.set(i,o))}}return t}const l=c(Array.from(n));e.debug(`dedup: Found ${l.size} duplicates among ${n.size} indices.`);const g=c(Array.from(o));e.debug(`dedup: Found ${g.size} duplicates among ${o.size} attributes.`);const u=c(Array.from(s)),f=c(Array.from(i));e.debug(`dedup: Found ${u.size+f.size} duplicates among ${s.size+i.size} animation accessors.`),a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(t=>{g.has(t)&&e.swap(t,g.get(t))});const t=e.getIndices();t&&l.has(t)&&e.swap(t,l.get(t))})}),Array.from(l.keys()).forEach(e=>e.dispose()),Array.from(g.keys()).forEach(e=>e.dispose());for(const e of t.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),n=t.getOutput();e&&u.has(e)&&t.swap(e,u.get(e)),n&&f.has(n)&&t.swap(n,f.get(n))}Array.from(u.keys()).forEach(e=>e.dispose()),Array.from(f.keys()).forEach(e=>e.dispose())}(t,e),s.has(n.MESH)&&function(e,t){const r=t.getRoot(),o=new Map;r.listAccessors().forEach((e,t)=>o.set(e,t)),r.listMaterials().forEach((e,t)=>o.set(e,t));const s=r.listMeshes().length,i=new Map;for(const e of r.listMeshes()){const t=[];for(const n of e.listPrimitives())t.push(se(n,o));const r=t.join(";");if(i.has(r)){const t=i.get(r);e.listParents().forEach(r=>{r.propertyType!==n.ROOT&&r.swap(e,t)}),e.dispose()}else i.set(r,e)}e.debug(`dedup: Found ${s-i.size} duplicates among ${s} meshes.`)}(t,e),s.has(n.TEXTURE)&&function(e,t){const n=t.getRoot(),s=n.listTextures(),i=new Map;for(let e=0;e<s.length;e++){const t=s[e],n=t.getImage();if(!i.has(t))for(let e=0;e<s.length;e++){const o=s[e],a=o.getImage();if(t===o)continue;if(i.has(o))continue;if(t.getMimeType()!==o.getMimeType())continue;const c=t.getSize(),l=o.getSize();c&&l&&c[0]===l[0]&&c[1]===l[1]&&n&&a&&r.equals(n,a)&&i.set(o,t)}}e.debug(`dedup: Found ${i.size} duplicates among ${n.listTextures().length} textures.`),Array.from(i.entries()).forEach(([e,t])=>{e.listParents().forEach(n=>{n instanceof o||n.swap(e,t)}),e.dispose()})}(t,e),s.has(n.MATERIAL)&&function(e,t){const n=t.getRoot(),r=n.listMaterials(),s=new Map,i=new Set(["name"]);for(let e=0;e<r.length;e++){const t=r[e];if(!s.has(t))for(let e=0;e<r.length;e++){const n=r[e];t!==n&&(s.has(n)||t.equals(n,i)&&s.set(n,t))}}e.debug(`dedup: Found ${s.size} duplicates among ${n.listMaterials().length} materials.`),Array.from(s.entries()).forEach(([e,t])=>{e.listParents().forEach(n=>{n instanceof o||n.swap(e,t)}),e.dispose()})}(t,e),t.debug("dedup: Complete.")})};function se(t,n){const r=[];for(const e of t.listSemantics()){const o=t.getAttribute(e);r.push(e+":"+n.get(o))}if(t instanceof e){const e=t.getIndices();e&&r.push("indices:"+n.get(e));const o=t.getMaterial();o&&r.push("material:"+n.get(o)),r.push("mode:"+t.getMode());for(const e of t.listTargets())r.push("target:"+se(e,n))}return r.join(",")}const ie={pattern:/^((?!JOINTS_).)*$/};function ae(e=ie){const t=F({},ie,e);return U("dequantize",e=>{const n=e.getLogger();for(const n of e.getRoot().listMeshes())for(const e of n.listPrimitives())ce(e,t);e.createExtension(T).dispose(),n.debug("dequantize: Complete.")})}function ce(e,t){for(const n of e.listSemantics())le(n,e.getAttribute(n),t);for(const n of e.listTargets())for(const e of n.listSemantics())le(e,n.getAttribute(e),t)}function le(e,t,n){if(!t.getArray())return;if(!n.pattern.test(e))return;if(t.getComponentSize()>=4)return;const r=t.getArray(),o=new Float32Array(r.length);for(let e=0,n=t.getCount(),s=[];e<n;e++)s=t.getElement(e,s),t.setArray(o).setElement(e,s).setArray(r);t.setArray(o).setNormalized(!1)}const ge={method:"edgebreaker",encodeSpeed:5,decodeSpeed:5,quantizePosition:14,quantizeNormal:10,quantizeColor:8,quantizeTexcoord:12,quantizeGeneric:12,quantizationVolume:"mesh"},ue=e=>{const t=F({},ge,e);return e=>{e.createExtension(S).setRequired(!0).setEncoderOptions({method:"edgebreaker"===t.method?S.EncoderMethod.EDGEBREAKER:S.EncoderMethod.SEQUENTIAL,encodeSpeed:t.encodeSpeed,decodeSpeed:t.decodeSpeed,quantizationBits:{POSITION:t.quantizePosition,NORMAL:t.quantizeNormal,COLOR:t.quantizeColor,TEX_COORD:t.quantizeTexcoord,GENERIC:t.quantizeGeneric},quantizationVolume:t.quantizationVolume})}};function fe(e){return{scenes:pe(e),meshes:me(e),materials:de(e),textures:he(e),animations:Ae(e)}}function pe(e){return{properties:e.getRoot().listScenes().map(e=>{const n=e.listChildren()[0],r=t(e);return{name:e.getName(),rootName:n?n.getName():"",bboxMin:Te(r.min),bboxMax:Te(r.max)}})}}function me(t){return{properties:t.getRoot().listMeshes().map(t=>{const r=t.listParents().filter(e=>e.propertyType!==n.ROOT).length;let o=0,s=0;const i=new Set,a=new Set,c=new Set;t.listPrimitives().forEach(t=>{for(const e of t.listSemantics()){const n=t.getAttribute(e);i.add(e+":"+Se(n)),c.add(n)}for(const e of t.listTargets())e.listAttributes().forEach(e=>c.add(e));const n=t.getIndices();n&&(a.add(Se(n)),c.add(n)),s+=t.listAttributes()[0].getCount(),o+=function(t){const n=t.getIndices(),r=t.getAttribute("POSITION");switch(t.getMode()){case e.Mode.POINTS:return r.getCount();case e.Mode.LINES:return n?n.getCount()/2:r.getCount()/2;case e.Mode.LINE_LOOP:return r.getCount();case e.Mode.LINE_STRIP:return r.getCount()-1;case e.Mode.TRIANGLES:return n?n.getCount()/3:r.getCount()/3;case e.Mode.TRIANGLE_STRIP:case e.Mode.TRIANGLE_FAN:return r.getCount()-2;default:throw new Error("Unexpected mode: "+t.getMode())}}(t)});let l=0;Array.from(c).forEach(e=>l+=e.getArray().byteLength);const g=t.listPrimitives().map(e=>ye[e.getMode()]);return{name:t.getName(),mode:Array.from(new Set(g)),primitives:t.listPrimitives().length,glPrimitives:o,vertices:s,indices:Array.from(a).sort(),attributes:Array.from(i).sort(),instances:r,size:l}})}}function de(e){return{properties:e.getRoot().listMaterials().map(t=>{const r=t.listParents().filter(e=>e.propertyType!==n.ROOT).length,o=new Set(t.listExtensions()),a=e.getGraph().listEdges().filter(e=>{const n=e.getChild(),r=e.getParent();return n instanceof s&&r===t||!!(n instanceof s&&r instanceof i&&o.has(r))}).map(e=>e.getName());return{name:t.getName(),instances:r,textures:a,alphaMode:t.getAlphaMode(),doubleSided:t.getDoubleSided()}})}}function he(e){return{properties:e.getRoot().listTextures().map(t=>{const r=t.listParents().filter(e=>e.propertyType!==n.ROOT).length,o=e.getGraph().listParentEdges(t).filter(e=>e.getParent().propertyType!==n.ROOT).map(e=>e.getName()),s=a.getSize(t.getImage(),t.getMimeType());return{name:t.getName(),uri:t.getURI(),slots:Array.from(new Set(o)),instances:r,mimeType:t.getMimeType(),resolution:s?s.join("x"):"",size:t.getImage().byteLength,gpuSize:a.getMemSize(t.getImage(),t.getMimeType())}})}}function Ae(e){return{properties:e.getRoot().listAnimations().map(e=>{let t=Infinity,n=-Infinity;e.listSamplers().forEach(e=>{const r=e.getInput();r&&(t=Math.min(t,r.getMin([])[0]),n=Math.max(n,r.getMax([])[0]))});let r=0,o=0;const s=new Set;return e.listSamplers().forEach(e=>{const t=e.getInput(),n=e.getOutput();t&&(o+=t.getCount(),s.add(t),n&&s.add(n))}),Array.from(s).forEach(e=>{r+=e.getArray().byteLength}),{name:e.getName(),channels:e.listChannels().length,samplers:e.listSamplers().length,duration:Math.round(1e3*(n-t))/1e3,keyframes:o,size:r}})}}const ye=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"],Ee={Float32Array:"f32",Uint32Array:"u32",Uint16Array:"u16",Uint8Array:"u8",Int32Array:"i32",Int16Array:"i16",Int8Array:"i8"};function Te(e){for(let t=0;t<e.length;t++)e[t].toFixed&&(e[t]=Number(e[t].toFixed(5)));return e}function Se(e){const t=e.getArray();return(Ee[t.constructor.name]||"?")+(e.getNormalized()?"_norm":"")}const Ie={};function be(e=Ie){return F({},Ie,e),U("instance",e=>{const t=e.getLogger(),n=e.getRoot(),r=e.createExtension(I);if(n.listAnimations().length)throw new Error("instance: Instancing is not currently supported for animated models.");let o=0,s=0;for(const i of n.listScenes()){const n=new Map;i.traverse(e=>{const t=e.getMesh();t&&n.set(t,(n.get(t)||new Set).add(e))});const a=[];for(const l of Array.from(n.keys())){const g=Array.from(n.get(l));if(g.length<2)continue;if(g.some(e=>e.getSkin()))continue;const u=Ne(e,r,l,g.length),f=u.getAttribute("TRANSLATION"),p=u.getAttribute("ROTATION"),m=u.getAttribute("SCALE"),d=e.createNode().setMesh(l).setExtension("EXT_mesh_gpu_instancing",u);i.addChild(d);let h=!1,A=!1,y=!1;for(let e=0;e<g.length;e++){let t,n,r;const o=g[e];f.setElement(e,t=o.getWorldTranslation()),p.setElement(e,n=o.getWorldRotation()),m.setElement(e,r=o.getWorldScale()),c.eq(t,[0,0,0])||(h=!0),c.eq(n,[0,0,0,1])||(A=!0),c.eq(r,[1,1,1])||(y=!0),o.setMesh(null),a.push(o)}h||f.dispose(),A||p.dispose(),y||m.dispose(),we(a,t),o++,s+=g.length}}o>0?t.info(`instance: Created ${o} batches, with ${s} total instances.`):(t.info("instance: No meshes with multiple parent nodes were found."),r.dispose()),t.debug("instance: Complete.")})}function we(e,t){let n,r=0;for(;n=e.pop();){if(n.listChildren().length||n.getCamera()||n.getMesh()||n.getSkin()||n.listExtensions().length)continue;const t=n.getParent();t instanceof l&&e.push(t),n.dispose(),r++}t.debug(`instance: Removed ${r} unused nodes.`)}function Ne(e,t,n,r){const o=n.listPrimitives()[0].getAttribute("POSITION").getBuffer(),s=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*r)).setBuffer(o),i=e.createAccessor().setType("VEC4").setArray(new Float32Array(4*r)).setBuffer(o),a=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*r)).setBuffer(o);return t.createInstancedMesh().setAttribute("TRANSLATION",s).setAttribute("ROTATION",i).setAttribute("SCALE",a)}const Me={propertyTypes:[n.NODE,n.SKIN,n.MESH,n.CAMERA,n.PRIMITIVE,n.PRIMITIVE_TARGET,n.ANIMATION,n.MATERIAL,n.TEXTURE,n.ACCESSOR,n.BUFFER],keepLeaves:!1},Re=function(e=Me){const t=F({},Me,e),r=new Set(t.propertyTypes);return U("prune",e=>{const s=e.getLogger(),i=e.getRoot(),a=e.getGraph(),c={};if(r.has(n.NODE)&&!t.keepLeaves&&i.listScenes().forEach(function e(t){if(t.listChildren().forEach(e),t instanceof u)return;const r=a.listParentEdges(t).some(e=>{const t=e.getParent().propertyType;return t!==n.ROOT&&t!==n.SCENE&&t!==n.NODE});0!==a.listChildren(t).length||r||(t.dispose(),p(t))}),r.has(n.NODE)&&i.listNodes().forEach(l),r.has(n.SKIN)&&i.listSkins().forEach(l),r.has(n.MESH)&&i.listMeshes().forEach(l),r.has(n.CAMERA)&&i.listCameras().forEach(l),r.has(n.PRIMITIVE)&&f(a,n.PRIMITIVE),r.has(n.PRIMITIVE_TARGET)&&f(a,n.PRIMITIVE_TARGET),r.has(n.ANIMATION))for(const e of i.listAnimations()){for(const t of e.listChannels())t.getTargetNode()||(t.dispose(),p(t));if(e.listChannels().length)e.listSamplers().forEach(l);else{const t=e.listSamplers();l(e),t.forEach(l)}}if(r.has(n.MATERIAL)&&i.listMaterials().forEach(l),r.has(n.TEXTURE)&&i.listTextures().forEach(l),r.has(n.ACCESSOR)&&i.listAccessors().forEach(l),r.has(n.BUFFER)&&i.listBuffers().forEach(l),Object.keys(c).length){const e=Object.keys(c).map(e=>`${e} (${c[e]})`).join(", ");s.info(`prune: Removed types... ${e}`)}else s.info("prune: No unused properties found.");function l(e){e.listParents().filter(e=>!(e instanceof o||e instanceof g)).length||(e.dispose(),p(e))}function f(e,t){e.listEdges().map(e=>e.getParent()).filter(e=>e.propertyType===t).forEach(l)}function p(e){c[e.propertyType]=c[e.propertyType]||0,c[e.propertyType]++}s.debug("prune: Complete.")})},Oe={target:"size"};function Ce(t){const r=F({},Oe,t),o=r.encoder;if(!o)throw new Error('reorder: encoder dependency required — install "meshoptimizer".');return U("reorder",async t=>{const s=t.getLogger();await o.ready;const i=Pe(t);for(const t of i.indicesToAttributes.keys()){const n=t.clone();let s=n.getArray().slice();s instanceof Uint32Array||(s=new Uint32Array(s));const[a,c]=o.reorderMesh(s,i.indicesToMode.get(t)===e.Mode.TRIANGLES,"size"===r.target);n.setArray(c<=65534?new Uint16Array(s):s);for(const e of i.indicesToAttributes.get(t)){const r=e.clone();Z(r,a,c);for(const o of i.attributesToPrimitives.get(e))if(o.getIndices()===t&&o.swap(t,n),o.getIndices()===n){o.swap(e,r);for(const t of o.listTargets())t.swap(e,r)}}}await t.transform(Re({propertyTypes:[n.ACCESSOR]})),i.indicesToAttributes.size?s.debug("reorder: Complete."):s.warn("reorder: No qualifying primitives found; may need to weld first.")})}function Pe(e){const t=new j,n=new Map,r=new j;for(const o of e.getRoot().listMeshes())for(const e of o.listPrimitives()){const o=e.getIndices();if(o){n.set(o,e.getMode());for(const n of K(e))t.add(o,n),r.add(n,e)}}return{indicesToAttributes:t,indicesToMode:n,attributesToPrimitives:r}}function xe(e,t=Infinity){if(Number.isFinite(t)&&t%4||t<=0)throw new Error("Limit must be positive multiple of four.");const n=e.getAttribute("POSITION").getCount(),r=e.listSemantics().filter(e=>e.startsWith("WEIGHTS_")).length,o=new Uint16Array(4*r),s=new Float32Array(4*r),i=new Float32Array(4*r),a=new Uint32Array(4*r),l=new Uint32Array(4*r);for(let t=0;t<n;t++){ze(e,t,"WEIGHTS",s),ze(e,t,"JOINTS",a);for(let e=0;e<4*r;e++)o[e]=e;o.sort((e,t)=>s[e]>s[t]?-1:1);for(let e=0;e<o.length;e++)i[e]=s[o[e]],l[e]=a[o[e]];$e(e,t,"WEIGHTS",i),$e(e,t,"JOINTS",l)}for(let n=r;4*n>t;n--){const t=e.getAttribute("WEIGHTS_"+(n-1)),r=e.getAttribute("JOINTS_"+(n-1));e.setAttribute("WEIGHTS_"+(n-1),null),e.setAttribute("JOINTS_"+(n-1),null),1===t.listParents().length&&t.dispose(),1===r.listParents().length&&r.dispose()}!function(e){if(!function(e){const t=e.listSemantics().filter(e=>e.startsWith("WEIGHTS_")).map(t=>e.getAttribute(t)),n=t.map(e=>e.getNormalized()),r=t.map(e=>e.getComponentType());return 1===new Set(n).size&&1===new Set(r).size}(e))return;const t=e.getAttribute("POSITION").getCount(),n=e.listSemantics().filter(e=>e.startsWith("WEIGHTS_")).length,r=e.getAttribute("WEIGHTS_0"),o=r.getArray(),s=r.getComponentType(),i=r.getNormalized(),a=i?c.denormalize(1,s):Number.EPSILON,l=o.slice(0,4*n).fill(0);for(let n=0;n<t;n++){ze(e,n,"WEIGHTS",l);let t=ve(l);if(0!==t){if(Math.abs(1-t)>a)for(let e=0;e<l.length;e++)if(i){const n=c.normalize(l[e]/t,s);l[e]=c.denormalize(n,s)}else l[e]/=t;if(t=ve(l),i&&1!==t)for(let e=l.length-1;e>=0;e--)if(l[e]>0){l[e]+=1-t;break}$e(e,n,"WEIGHTS",l)}}}(e)}function ze(e,t,n,r){let o;const s=[0,0,0,0];for(let i=0;o=e.getAttribute(`${n}_${i}`);i++){o.getElement(t,s);for(let e=0;e<4;e++)r[4*i+e]=s[e]}return r}function $e(e,t,n,r){let o;const s=[0,0,0,0];for(let i=0;o=e.getAttribute(`${n}_${i}`);i++){for(let e=0;e<4;e++)s[e]=r[4*i+e];o.setElement(t,s)}}function ve(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}const Le=[Int8Array,Int16Array,Int32Array],{TRANSLATION:_e,ROTATION:qe,SCALE:Ge,WEIGHTS:ke}=g.TargetPath,Be=[_e,qe,Ge],Fe={pattern:/.*/,quantizationVolume:"mesh",quantizePosition:14,quantizeNormal:10,quantizeTexcoord:12,quantizeColor:8,quantizeWeight:8,quantizeGeneric:12,normalizeWeights:!0},Ue=(e=Fe)=>{const t=F({},Fe,e);return U("quantize",async e=>{const r=e.getLogger(),o=e.getRoot();let s;e.createExtension(T).setRequired(!0),"scene"===t.quantizationVolume&&(s=He(function(e){const t=e[0];for(const n of e)v(t.min,t.min,n.min),_(t.max,t.max,n.max);return t}(o.listMeshes().map(Je))));for(const n of e.getRoot().listMeshes()){"mesh"===t.quantizationVolume&&(s=He(Je(n))),s&&t.pattern.test("POSITION")&&(je(e,n,s),De(n,1/s.scale));for(const r of n.listPrimitives()){We(e,r,s,t);for(const n of r.listTargets())We(e,n,s,t)}}await e.transform(Re({propertyTypes:[n.ACCESSOR,n.SKIN,n.MATERIAL]}),oe({propertyTypes:[n.ACCESSOR,n.MATERIAL]})),r.debug("quantize: Complete.")})};function We(t,n,r,o){const s=t.getLogger();for(const t of n.listSemantics()){if(!o.pattern.test(t))continue;const i=n.getAttribute(t),{bits:a,ctor:c}=Ke(t,i,s,o);if(!c)continue;if(a<8||a>16)throw new Error("quantize: Requires bits = 8–16.");if(i.getComponentSize()<=a/8)continue;const l=i.clone();if("POSITION"===t){const t=r.scale,o=[];n instanceof e?C(o,Qe(r)):x(o,[1/t,1/t,1/t]);for(let e=0,t=[0,0,0],n=l.getCount();e<n;e++)l.getElement(e,t),l.setElement(e,$(t,t,o))}Xe(l,c,a),n.swap(i,l)}if(o.normalizeWeights&&n.getAttribute("WEIGHTS_0")&&xe(n,Infinity),n instanceof e&&n.getIndices()&&n.listAttributes().length&&n.listAttributes()[0].getCount()<65535){const e=n.getIndices();e.setArray(new Uint16Array(e.getArray()))}}function He(e){const{min:t,max:n}=e,r=Math.max((n[0]-t[0])/2,(n[1]-t[1])/2,(n[2]-t[2])/2);return{offset:[t[0]+(n[0]-t[0])/2,t[1]+(n[1]-t[1])/2,t[2]+(n[2]-t[2])/2],scale:r}}function je(e,t,n){const r=Qe(n);for(const o of t.listParents()){if(!(o instanceof l))continue;const s=o.listParents().filter(e=>e instanceof g),i=s.some(e=>Be.includes(e.getTargetPath())),a=o.listChildren().length>0;if(o.getSkin()){o.setSkin(Ve(o.getSkin(),n));continue}let c;a||i?(c=e.createNode("").setMesh(t),o.addChild(c).setMesh(null),s.filter(e=>e.getTargetPath()===ke).forEach(e=>e.setTargetNode(c))):c=o;const u=c.getMatrix();z(u,u,r),c.setMatrix(u)}}function Ve(e,t){e=e.clone();const n=Qe(t),r=e.getInverseBindMatrices().clone(),o=[];for(let e=0,t=r.getCount();e<t;e++)r.getElement(e,o),z(o,o,n),r.setElement(e,o);return e.setInverseBindMatrices(r)}function De(e,t){for(const n of e.listPrimitives()){let e=n.getMaterial();if(!e)continue;let r=e.getExtension("KHR_materials_volume");!r||r.getThicknessFactor()<=0||(r=r.clone().setThicknessFactor(r.getThicknessFactor()*t),e=e.clone().setExtension("KHR_materials_volume",r),n.setMaterial(e))}}function Xe(e,t,n){const r=new t(e.getArray().length),o=Le.includes(t)?1:0,s=n-o,i=8*t.BYTES_PER_ELEMENT-o,a=Math.pow(2,s)-1,c=i-s,l=2*s-i;for(let t=0,n=0,o=[];t<e.getCount();t++){e.getElement(t,o);for(let e=0;e<o.length;e++){let t=Math.round(Math.abs(o[e])*a);t=t<<c|t>>l,r[n++]=t*Math.sign(o[e])}}e.setArray(r).setNormalized(!0)}function Ke(e,t,n,r){const o=t.getMinNormalized([]),s=t.getMaxNormalized([]);let i,a;if("POSITION"===e)i=r.quantizePosition,a=i<=8?Int8Array:Int16Array;else if("NORMAL"===e||"TANGENT"===e)i=r.quantizeNormal,a=i<=8?Int8Array:Int16Array;else if(e.startsWith("COLOR_"))i=r.quantizeColor,a=i<=8?Uint8Array:Uint16Array;else if(e.startsWith("TEXCOORD_")){if(o.some(e=>e<0)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=r.quantizeTexcoord,a=i<=8?Uint8Array:Uint16Array}else{if(e.startsWith("JOINTS_"))return i=Math.max(...t.getMax([]))<=255?8:16,a=i<=8?Uint8Array:Uint16Array,t.getComponentSize()>i/8&&t.setArray(new a(t.getArray())),{bits:-1};if(e.startsWith("WEIGHTS_")){if(o.some(e=>e<0)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=r.quantizeWeight,a=i<=8?Uint8Array:Uint16Array}else{if(!e.startsWith("_"))throw new Error(`quantize: Unexpected semantic, "${e}".`);if(o.some(e=>e<-1)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [-1,1] range.`),{bits:-1};i=r.quantizeGeneric,a=a=o.some(e=>e<0)?i<=8?Int8Array:Int16Array:i<=8?Uint8Array:Uint16Array}}return{bits:i,ctor:a}}function Je(e){const t=[],n=[];for(const r of e.listPrimitives()){const e=r.getAttribute("POSITION");e&&t.push(e);for(const e of r.listTargets()){const t=e.getAttribute("POSITION");t&&n.push(t)}}if(0===t.length)throw new Error('quantize: Missing "POSITION" attribute.');const r=Ze(t,3);if(n.length>0){const{min:e,max:t}=Ze(n,3);v(r.min,r.min,v(e,L(e,e,2),[0,0,0])),_(r.max,r.max,_(t,L(t,t,2),[0,0,0]))}return r}function Ze(e,t){const n=new Array(t).fill(Infinity),r=new Array(t).fill(-Infinity),o=[],s=[];for(const i of e){i.getMinNormalized(o),i.getMaxNormalized(s);for(let e=0;e<t;e++)n[e]=Math.min(n[e],o[e]),r[e]=Math.max(r[e],s[e])}return{min:n,max:r}}function Qe(e){return P([],[0,0,0,1],e.offset,[e.scale,e.scale,e.scale])}const Ye={level:"high"},et=e=>{const t=F({},Ye,e),n=t.encoder;if(!n)throw new Error('meshopt: encoder dependency required — install "meshoptimizer".');return async e=>{await e.transform(Ce({encoder:n,target:"size"}),Ue({pattern:"medium"===t.level?/.*/:/^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\d+)?$/,quantizePosition:14,quantizeTexcoord:12,quantizeColor:8,quantizeNormal:8})),e.createExtension(b).setRequired(!0).setEncoderOptions({method:"medium"===t.level?b.EncoderMethod.QUANTIZE:b.EncoderMethod.FILTER})}},tt={};function nt(e=tt){return F({},tt,e),U("metalRough",async e=>{const t=e.getLogger();if(!e.getRoot().listExtensionsUsed().map(e=>e.extensionName).includes("KHR_materials_pbrSpecularGlossiness"))return void t.warn("metalRough: KHR_materials_pbrSpecularGlossiness not found on document.");const n=e.createExtension(w),r=e.createExtension(N),o=e.createExtension(M),s=new Set;for(const t of e.getRoot().listMaterials()){const o=t.getExtension("KHR_materials_pbrSpecularGlossiness");if(!o)continue;const i=r.createSpecular().setSpecularFactor(1).setSpecularColorFactor(o.getSpecularFactor());s.add(o.getSpecularGlossinessTexture()),s.add(t.getBaseColorTexture()),s.add(t.getMetallicRoughnessTexture()),t.setBaseColorFactor(o.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",n.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",i);const a=o.getDiffuseTexture();a&&(t.setBaseColorTexture(a),t.getBaseColorTextureInfo().copy(o.getDiffuseTextureInfo()));const c=o.getSpecularGlossinessTexture();if(c){const n=o.getSpecularGlossinessTextureInfo(),r=e.createTexture();await H(c,r,(e,t,n)=>{e.set(t,n,3,255)}),i.setSpecularTexture(r),i.setSpecularColorTexture(r),i.getSpecularTextureInfo().copy(n),i.getSpecularColorTextureInfo().copy(n);const s=o.getGlossinessFactor(),a=e.createTexture();await H(c,a,(e,t,n)=>{const r=255-Math.round(e.get(t,n,3)*s);e.set(t,n,0,0),e.set(t,n,1,r),e.set(t,n,2,0),e.set(t,n,3,255)}),t.setMetallicRoughnessTexture(a),t.getMetallicRoughnessTextureInfo().copy(n)}else i.setSpecularColorFactor(o.getSpecularFactor()),t.setRoughnessFactor(1-o.getGlossinessFactor());t.setExtension("KHR_materials_pbrSpecularGlossiness",null)}o.dispose();for(const e of s)e&&1===e.listParents().length&&e.dispose();t.debug("metalRough: Complete.")})}const rt={};function ot(e=rt){return F({},rt,e),U("unweld",e=>{const t=e.getLogger(),n=new Map;for(const r of e.getRoot().listMeshes())for(const e of r.listPrimitives()){const r=e.getIndices();if(!r)continue;const o=e.getAttribute("POSITION").getCount();for(const o of e.listAttributes())e.swap(o,st(o,r,t,n)),1===o.listParents().length&&o.dispose();for(const o of e.listTargets())for(const e of o.listAttributes())o.swap(e,st(e,r,t,n)),1===e.listParents().length&&e.dispose();const s=e.getAttribute("POSITION").getCount();t.debug(`unweld: ${X(o,s)} vertices.`),e.setIndices(null),1===r.listParents().length&&r.dispose()}t.debug("unweld: Complete.")})}function st(e,t,n,r){if(r.has(e)&&r.get(e).has(t))return n.debug(`unweld: Cache hit for reused attribute, "${e.getName()}".`),r.get(e).get(t);const o=e.clone(),s=e.getArray().constructor;o.setArray(new s(t.getCount()*e.getElementSize()));const i=[];for(let n=0;n<t.getCount();n++)o.setElement(n,e.getElement(t.getScalar(n),i));return r.has(e)||r.set(e,new Map),r.get(e).set(t,o),o}const it={overwrite:!1};function at(e=it){const t=F({},it,e);return U("normals",async e=>{const n=e.getLogger();let r=0;await e.transform(ot());for(const o of e.getRoot().listMeshes())for(const s of o.listPrimitives()){const o=s.getAttribute("POSITION");let i=s.getAttribute("NORMAL");if(t.overwrite&&i)i.dispose();else if(i){n.debug("normals: Skipping primitive: NORMAL found.");continue}i=e.createAccessor().setArray(new Float32Array(3*o.getCount())).setType("VEC3");const a=[0,0,0],c=[0,0,0],l=[0,0,0];for(let e=0;e<o.getCount();e+=3){o.getElement(e+0,a),o.getElement(e+1,c),o.getElement(e+2,l);const t=ct(a,c,l);i.setElement(e+0,t),i.setElement(e+1,t),i.setElement(e+2,t)}s.setAttribute("NORMAL",i),r++}r?n.debug("normals: Complete."):n.warn("normals: No qualifying primitives found. See debug output.")})}function ct(e,t,n){const r=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],o=[n[0]-e[0],n[1]-e[1],n[2]-e[2]];return q([0,0,0],[r[1]*o[2]-r[2]*o[1],r[2]*o[0]-r[0]*o[2],r[0]*o[1]-r[1]*o[0]])}const lt={animations:!0,meshes:!0},gt=(e=lt)=>{const t=F({},lt,e);return U("partition",async e=>{const r=e.getLogger();!1!==t.meshes&&function(e,t,n){const r=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listMeshes().forEach((o,s)=>{if(Array.isArray(n.meshes)&&!n.meshes.includes(o.getName()))return void t.debug(`partition: Skipping mesh #${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for mesh "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(ut(o.getName()||"mesh",r));o.listPrimitives().forEach(e=>{const t=e.getIndices();t&&t.setBuffer(i),e.listAttributes().forEach(e=>e.setBuffer(i)),e.listTargets().forEach(e=>{e.listAttributes().forEach(e=>e.setBuffer(i))})})})}(e,r,t),!1!==t.animations&&function(e,t,n){const r=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listAnimations().forEach((o,s)=>{if(Array.isArray(n.animations)&&!n.animations.includes(o.getName()))return void t.debug(`partition: Skipping animation #${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for animation "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(ut(o.getName()||"animation",r));o.listSamplers().forEach(e=>{const t=e.getInput(),n=e.getOutput();t&&t.setBuffer(i),n&&n.setBuffer(i)})})}(e,r,t),t.meshes||t.animations||r.warn("partition: Select animations or meshes to create a partition."),await e.transform(Re({propertyTypes:[n.BUFFER]})),r.debug("partition: Complete.")})};function ut(e,t){let n=`${e}.bin`,r=1;for(;t.has(n);)n=`${e}_${r++}.bin`;return n}const ft={tolerance:1e-4},pt=(e=ft)=>{const t=F({},ft,e);return U("resample",(e,n)=>{const r=new Set,s=e.getRoot().listAccessors().length,i=e.getLogger();let a=!1;for(const n of e.getRoot().listAnimations()){const e=new Set;for(const t of n.listChannels())t.getSampler()&&"weights"===t.getTargetPath()&&e.add(t.getSampler());for(const o of n.listSamplers())e.has(o)?a=!0:"STEP"!==o.getInterpolation()&&"LINEAR"!==o.getInterpolation()||(r.add(o.getInput()),r.add(o.getOutput()),mt(o,t))}for(const e of Array.from(r.values()))e.listParents().some(e=>!(e instanceof o))||e.dispose();e.getRoot().listAccessors().length>s&&!W(n,"resample","dedup")&&i.warn('resample: Resampling required copying accessors, some of which may be duplicates. Consider using "dedup" to consolidate any duplicates.'),a&&i.warn("resample: Skipped optimizing morph target keyframes, not yet supported."),i.debug("resample: Complete.")})};function mt(e,t){const n=e.getInput().clone(),r=e.getOutput().clone(),o=t.tolerance,s=n.getCount()-1,i=[];let a=1;for(let t=1;t<s;++t){const s=n.getScalar(t),l=n.getScalar(t-1),g=n.getScalar(t+1),u=(s-l)/(g-l);let f=!1;if(s!==g&&(1!==t||s!==n.getScalar(0)))for(let n=0;n<r.getElementSize();n++){const s=r.getElement(t,i)[n],a=r.getElement(t-1,i)[n],l=r.getElement(t+1,i)[n];if("LINEAR"===e.getInterpolation()){if(Math.abs(s-(a*(1-(c=u))+l*c))>o){f=!0;break}}else if("STEP"===e.getInterpolation()&&(s!==a||s!==l)){f=!0;break}}f&&(t!==a&&(n.setScalar(a,n.getScalar(t)),r.setElement(a,r.getElement(t,i))),a++)}var c;s>0&&(n.setScalar(a,n.getScalar(s)),r.setElement(a,r.getElement(s,i)),a++),a!==n.getCount()?(n.setArray(n.getArray().slice(0,a)),r.setArray(r.getArray().slice(0,a*r.getElementSize())),e.setInput(n),e.setOutput(r)):(n.dispose(),r.dispose())}const dt={name:"",fps:10,pattern:/.*/,sort:!0};function ht(e=dt){const t=F({},dt,e);return U("sequence",e=>{const n=e.getLogger(),r=e.getRoot(),o=t.fps,s=r.listNodes().filter(e=>e.getName().match(t.pattern));t.sort&&s.sort((e,t)=>e.getName()>t.getName()?1:-1);const i=e.createAnimation(t.name),a=r.listBuffers()[0];s.forEach((t,n)=>{let r,c;0===n?(r=[n/o,(n+1)/o],c=[1,1,1,0,0,0]):n===s.length-1?(r=[(n-1)/o,n/o],c=[0,0,0,1,1,1]):(r=[(n-1)/o,n/o,(n+1)/o],c=[0,0,0,1,1,1,0,0,0]);const l=e.createAccessor().setArray(new Float32Array(r)).setBuffer(a),u=e.createAccessor().setArray(new Float32Array(c)).setBuffer(a).setType(f.Type.VEC3),m=e.createAnimationSampler().setInterpolation(p.Interpolation.STEP).setInput(l).setOutput(u),d=e.createAnimationChannel().setTargetNode(t).setTargetPath(g.TargetPath.SCALE).setSampler(m);i.addSampler(m).addChannel(d)}),n.debug("sequence: Complete.")})}const At={tolerance:1e-4,overwrite:!0};function yt(t=At){const r=F({},At,t);if(r.tolerance>.1||r.tolerance<0)throw new Error("weld: Requires 0 ≤ tolerance ≤ 0.1");return U("weld",async(t,o)=>{const s=t.getLogger();for(const n of t.getRoot().listMeshes())for(const o of n.listPrimitives())o.getIndices()&&!r.overwrite||o.getMode()!==e.Mode.POINTS&&(0===r.tolerance?Et(t,o):Tt(t,o,r));W(o,"weld","dedup")||await t.transform(oe({propertyTypes:[n.ACCESSOR]})),s.debug("weld: Complete.")})}function Et(e,t){if(t.getIndices())return;const n=t.listAttributes()[0],r=n.getCount(),o=n.getBuffer(),s=r<=65534?new Uint16Array(r):new Uint32Array(r),i=e.createAccessor().setBuffer(o).setType(f.Type.SCALAR).setArray(s);for(let e=0;e<i.getCount();e++)i.setScalar(e,e);t.setIndices(i)}function Tt(e,t,n){const r=e.getLogger(),o=t.getAttribute("POSITION"),s=t.getIndices()||e.createAccessor().setArray(Q(o.getCount())),i=new Uint32Array(new Set(s.getArray())),a=Math.max(n.tolerance,Number.EPSILON),c={};for(const e of t.listSemantics()){const n=t.getAttribute(e);c[e]=wt(e,n,a)}var l;r.debug(`weld: Tolerance thresholds: ${l=c,Object.entries(l).map(([e,t])=>`${e}=${t}`).join(", ")}`);const g=[0,0,0],u=[0,0,0];i.sort((e,t)=>(o.getElement(e,g),o.getElement(t,u),g[0]>u[0]?1:-1));const f=Q(i.length),p=Q(i.length),m=o.getCount();let d=0,h=0;for(let e=0;e<i.length;e++){const n=i[e];for(let r=e-1;r>=0;r--){const e=f[i[r]];if(o.getElement(n,g),o.getElement(e,u),Math.abs(g[0]-u[0])>c.POSITION)break;h++;const s=t.listSemantics().every(r=>Nt(t.getAttribute(r),n,e,c[r])),a=t.listTargets().every(t=>t.listSemantics().every(r=>Nt(t.getAttribute(r),n,e,c[r])));if(s&&a){f[n]=e;break}}p[n]=f[n]===n?d++:p[f[n]]}r.debug(`weld: Iterations per vertex: ${Math.round(h/i.length)} (avg)`),r.debug(`weld: ${X(m,d)} vertices.`);const A=s.getCount(),y=Q(A,i.length);for(let e=0;e<A;e++)y[e]=p[s.getScalar(e)];t.setIndices(s.clone().setArray(y)),1===s.listParents().length&&s.dispose();for(const e of t.listAttributes())St(t,e,p,d);for(const e of t.listTargets())for(const t of e.listAttributes())St(e,t,p,d)}function St(e,t,n,r){const o=(s=t.getArray(),i=r*t.getElementSize(),new(0,s.constructor)(i));var s,i;const a=t.clone().setArray(o),c=new Uint8Array(r);for(let e=0,r=[];e<n.length;e++)c[n[e]]||(a.setElement(n[e],t.getElement(e,r)),c[n[e]]=1);e.swap(t,a),1===t.listParents().length&&t.dispose()}const It=[],bt=[];function wt(e,t,n){return"NORMAL"===e||"TANGENT"===e?.5:e.startsWith("COLOR_")?.01:e.startsWith("TEXCOORD_")?1e-4:e.startsWith("JOINTS_")?0:e.startsWith("WEIGHTS_")?.01:(It.length=bt.length=0,t.getMinNormalized(It),t.getMaxNormalized(bt),n*(Math.max(...bt)-Math.min(...It)||1))}function Nt(e,t,n,r,o){e.getElement(t,It),e.getElement(n,bt);for(let t=0,n=e.getElementSize();t<n;t++)if(Math.abs(It[t]-bt[t])>r)return!1;return!0}const Mt={ratio:.5,error:.001,lockBorder:!1},Rt=t=>{const r=F({},Mt,t),o=r.simplifier;if(!o)throw new Error('simplify: simplifier dependency required — install "meshoptimizer".');return U("simplify",async(t,s)=>{const i=t.getLogger();await o.ready,await t.transform(yt({overwrite:!1}));for(const n of t.getRoot().listMeshes())for(const o of n.listPrimitives())o.getMode()===e.Mode.TRIANGLES?Ot(t,o,r):i.warn(`simplify: Skipping primitive of mesh "${n.getName()}": Requires TRIANGLES draw mode.`);W(s,"simplify","dedup")||await t.transform(oe({propertyTypes:[n.ACCESSOR]})),i.debug("simplify: Complete.")})};function Ot(e,t,n){const r=F({},Mt,n),o=e.getLogger(),s=t.getAttribute("POSITION"),i=t.getIndices(),a=s.getCount();let c=s.getArray(),l=i.getArray();if(s.getComponentType()!==f.ComponentType.FLOAT)if(s.getNormalized()){const e=c,t=new Float32Array(e.length);for(let n=0,r=s.getCount(),o=[];n<r;n++)o=s.getElement(n,o),s.setArray(t).setElement(n,o).setArray(e);c=t}else c=new Float32Array(c);i.getComponentType()!==f.ComponentType.UNSIGNED_INT&&(l=new Uint32Array(l));const g=3*Math.floor(r.ratio*a/3),[u,p]=r.simplifier.simplify(l,c,3,g,r.error,r.lockBorder?["LockBorder"]:[]),[m,d]=r.simplifier.compactMesh(u);o.debug(`simplify: ${X(s.getCount(),d)} vertices, error: ${p.toFixed(4)}.`);for(const e of K(t)){const n=e.clone();Z(n,m,d),J(t,e,n),1===e.listParents().length&&e.dispose()}const h=i.clone();return h.setArray(a<=65534?new Uint16Array(u):u),t.setIndices(h),1===i.listParents().length&&i.dispose(),t}function Ct(e,t){const n=Pt(e,t),r=[];return n&d.R&&r.push(d.R),n&d.G&&r.push(d.G),n&d.B&&r.push(d.B),n&d.A&&r.push(d.A),r}function Pt(e,t){let r=0;for(const o of e.getGraph().listParentEdges(t)){const t=o.getParent();let{channels:s}=o.getAttributes();s&&"baseColorTexture"===o.getName()&&t instanceof m&&t.getAlphaMode()===m.AlphaMode.OPAQUE&&(s&=~d.A),s?r|=s:t.propertyType!==n.ROOT&&e.getLogger().warn(`Missing attribute ".channels" on edge, "${o.getName()}".`)}return r}function xt(e,t){const n=e.getRoot(),r=e.getGraph().listParentEdges(t).filter(e=>e.getParent()!==n).map(e=>e.getName());return Array.from(new Set(r))}var zt;!function(e){e.OXIPNG="oxipng",e.MOZJPEG="mozjpeg",e.WEBP="webp"}(zt||(zt={}));const $t={[zt.OXIPNG]:"image/png",[zt.MOZJPEG]:"image/jpeg",[zt.WEBP]:"image/webp"},vt={jobs:4,formats:/.*/,slots:/.*/,auto:!1},Lt=F({},vt,{codec:zt.WEBP}),_t=F({},vt,{codec:zt.MOZJPEG,formats:/^image\/jpeg$/}),qt=F({},vt,{codec:zt.OXIPNG,formats:/^image\/png$/}),Gt=["image/jpeg","image/png","image/webp"];let kt=null,Bt=0;const Ft=(e,t)=>(kt||(kt=new e.ImagePool(t)),Bt++,kt),Ut=()=>{Bt--,kt&&Bt<=0&&(kt.close(),kt=null)},Wt=function(e){const t=F({},vt,e),n=t.squoosh,r=t.codec;if(!n)throw new Error(`${r}: squoosh dependency required — install "@squoosh/lib".`);return async e=>{const o=e.getLogger(),s=e.getRoot().listTextures(),i=Ft(n,t.jobs);await Promise.all(s.map(async(n,s)=>{const a=xt(e,n),c=Pt(e,n),l=n.getURI()||n.getName()||`${s+1}/${e.getRoot().listTextures().length}`,g=`${r}:texture(${l})`;if(!Gt.includes(n.getMimeType()))return void o.debug(`${g}: Skipping, unsupported texture type "${n.getMimeType()}".`);if(!t.formats.test(n.getMimeType()))return void o.debug(`${g}: Skipping, "${n.getMimeType()}" excluded by "formats" parameter.`);if(a.length&&!a.some(e=>t.slots.test(e)))return void o.debug(`${g}: Skipping, [${a.join(", ")}] excluded by "slots" parameter.`);if(t.codec===zt.MOZJPEG&&c&d.A)return void o.warn(`${g}: Skipping, [${a.join(", ")}] requires alpha channel.`);o.debug(`${g}: Slots → [${a.join(", ")}]`);const u=i.ingestImage(n.getImage()),f=n.getImage().byteLength;await u.encode({[t.codec]:t.auto?"auto":{}});const p=await u.encodedWith[t.codec];o.debug(`${g}: ${JSON.stringify(p.optionsUsed)}`),n.setImage(p.binary).setMimeType($t[t.codec]);const m=p.binary.byteLength;o.debug(`${g}: ${V(f)} → ${V(m)}`)})),Ut(),o.debug(`${r}: Complete.`)}},Ht=function(e){const t=F({},Lt,e);return async e=>{await Wt(t)(e),e.getRoot().listTextures().some(e=>e.getMimeType()===$t[zt.WEBP])&&e.createExtension(R).setRequired(!0)}},jt=function(e){const t=F({},_t,e);return e=>Wt(t)(e)},Vt=function(e){const t=F({},qt,e);return e=>Wt(t)(e)},Dt={overwrite:!1};function Xt(e=Dt){if(!e.generateTangents)throw new Error('tangents: generateTangents callback required — install "mikktspace".');const t=F({},Dt,e);return U("tangents",e=>{const n=e.getLogger(),r=new Map,o=new Map;let s=0;for(const i of e.getRoot().listMeshes()){const a=i.getName(),c=i.listPrimitives();for(let i=0;i<c.length;i++){const l=c[i];if(!Jt(l,n,a,i,t.overwrite))continue;const g=Kt(l),u=l.getAttribute("POSITION").getArray(),f=l.getAttribute("NORMAL").getArray(),p=l.getAttribute(g).getArray(),m=r.get(u)||h();r.set(u,m);const d=r.get(f)||h();r.set(f,d);const A=r.get(p)||h();r.set(p,A);const y=l.getAttribute("TANGENT");y&&2===y.listParents().length&&y.dispose();const E=`${m}|${d}|${A}`;let T=o.get(E);if(T){n.debug(`tangents: Found cache for primitive ${i} of mesh "${a}".`),l.setAttribute("TANGENT",T),s++;continue}n.debug(`tangents: Generating for primitive ${i} of mesh "${a}".`);const S=l.getAttribute("POSITION").getBuffer(),I=t.generateTangents(u instanceof Float32Array?u:new Float32Array(u),f instanceof Float32Array?f:new Float32Array(f),p instanceof Float32Array?p:new Float32Array(p));for(let e=3;e<I.length;e+=4)I[e]*=-1;T=e.createAccessor().setBuffer(S).setArray(I).setType("VEC4"),l.setAttribute("TANGENT",T),o.set(E,T),s++}}s?n.debug("tangents: Complete."):n.warn("tangents: No qualifying primitives found. See debug output.")})}function Kt(e){const t=e.getMaterial();if(!t)return"TEXCOORD_0";const n=t.getNormalTextureInfo();if(!n)return"TEXCOORD_0";const r=`TEXCOORD_${n.getTexCoord()}`;return e.getAttribute(r)?r:"TEXCOORD_0"}function Jt(t,n,r,o,s){return t.getMode()===e.Mode.TRIANGLES&&t.getAttribute("POSITION")&&t.getAttribute("NORMAL")&&t.getAttribute("TEXCOORD_0")?t.getAttribute("TANGENT")&&!s?(n.debug(`tangents: Skipping primitive ${o} of mesh "${r}": TANGENT found.`),!1):!t.getIndices()||(n.warn(`tangents: Skipping primitive ${o} of mesh "${r}": primitives must be unwelded.`),!1):(n.debug(`tangents: Skipping primitive ${o} of mesh "${r}": primitives must have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.`),!1)}const Zt="textureResize";var Qt;!function(e){e.LANCZOS3="lanczos3",e.LANCZOS2="lanczos2"}(Qt||(Qt={}));const Yt={size:[2048,2048],filter:Qt.LANCZOS3,pattern:null,slots:null};function en(e=Yt){const t=F({},Yt,e);return U(Zt,async e=>{const n=e.getLogger();for(const r of e.getRoot().listTextures()){const o=r.getName(),s=r.getURI();if(t.pattern&&!t.pattern.test(o)&&!t.pattern.test(s)){n.debug(`${Zt}: Skipping, excluded by "pattern" parameter.`);continue}if("image/png"!==r.getMimeType()&&"image/jpeg"!==r.getMimeType()){n.warn(`${Zt}: Skipping, unsupported texture type "${r.getMimeType()}".`);continue}const i=xt(e,r);if(t.slots&&!i.some(e=>{var n;return null==(n=t.slots)?void 0:n.test(e)})){n.debug(`${Zt}: Skipping, [${i.join(", ")}] excluded by "slots" parameter.`);continue}const[a,c]=t.size,[l,g]=r.getSize();if(l<=a&&g<=c){n.debug(`${Zt}: Skipping, not within size range.`);continue}let u=l,f=g;u>a&&(f=Math.floor(f*(a/u)),u=a),f>c&&(u=Math.floor(u*(c/f)),f=c);const p=r.getImage(),m=await y(p,r.getMimeType()),d=G(new Uint8Array(u*f*4),[u,f,4]);n.debug(`${Zt}: Resizing "${s||o}", ${m.shape} → ${d.shape}...`),n.debug(`${Zt}: Slots → [${i.join(", ")}]`);try{t.filter===Qt.LANCZOS3?k(m,d):B(m,d)}catch(e){if(e instanceof Error){n.warn(`${Zt}: Failed to resize "${s||o}": "${e.message}".`);continue}throw e}r.setImage(await E(d,r.getMimeType()))}n.debug(`${Zt}: Complete.`)})}const tn=()=>e=>{const t=e.createExtension(O).createUnlit();e.getRoot().listMaterials().forEach(e=>{e.setExtension("KHR_materials_unlit",t)})},nn={},rn=(e=nn)=>(F({},nn,e),U("unpartition",async e=>{const t=e.getLogger(),n=e.getRoot().listBuffers()[0];e.getRoot().listAccessors().forEach(e=>e.setBuffer(n)),e.getRoot().listBuffers().forEach((e,t)=>t>0?e.dispose():null),t.debug("unpartition: Complete.")}));function on(e,t){const n=e.getGraph(),r=[];for(const e of n.listParentEdges(t)){const t=e.getParent(),o=e.getName()+"Info";for(const e of n.listChildEdges(t)){const t=e.getChild();t instanceof A&&e.getName()===o&&r.push(t)}}return r}export{ge as DRACO_DEFAULTS,Ye as MESHOPT_DEFAULTS,Fe as QUANTIZE_DEFAULTS,Mt as SIMPLIFY_DEFAULTS,Yt as TEXTURE_RESIZE_DEFAULTS,Qt as TextureResizeFilter,At as WELD_DEFAULTS,ee as center,ne as colorspace,Pe as createLayoutPlan,oe as dedup,ae as dequantize,ue as draco,Pt as getTextureChannelMask,fe as inspect,be as instance,Ct as listTextureChannels,on as listTextureInfo,xt as listTextureSlots,et as meshopt,nt as metalRough,jt as mozjpeg,at as normals,Vt as oxipng,gt as partition,Re as prune,Ue as quantize,Ce as reorder,pt as resample,ht as sequence,Rt as simplify,Ot as simplifyPrimitive,xe as sortPrimitiveWeights,Wt as squoosh,Xt as tangents,en as textureResize,tn as unlit,rn as unpartition,ot as unweld,Ht as webp,yt as weld};
//# sourceMappingURL=functions.modern.js.map
